<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Mini Maze — MiniFun</title>
  <link href="style.css" rel="stylesheet" type="text/css">
  <style>
    .maze-wrap{max-width:880px;margin:28px auto;padding:18px;border-radius:12px;background:linear-gradient(180deg,#fff,#f7fbff);box-shadow:0 10px 30px rgba(2,12,27,0.06)}
    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:12px}
    canvas{background:#fafcff;border-radius:8px;display:block;width:100%;height:auto}
    .stats{display:flex;gap:14px;align-items:center;margin-top:10px}
    button{padding:8px 10px;border-radius:8px;border:none;background:#0b66c2;color:#fff;cursor:pointer}
    input[type=range]{width:160px}
    @media(max-width:540px){.controls{flex-direction:column;align-items:stretch}}
  </style>
</head>
<body>
  <main class="maze-wrap">
    <h1>Mini Maze</h1>
    <div class="controls">
      <label>Size: <input id="sizeRange" type="range" min="8" max="48" value="24"></label>
      <label>Cell px: <input id="cellRange" type="range" min="8" max="36" value="20"></label>
      <button id="genBtn">Generate</button>
      <button id="solveBtn">Show Path</button>
      <button id="resetBtn" style="background:#ef5350">Reset</button>
      <div style="margin-left:auto">Moves: <span id="moves">0</span></div>
    </div>

    <canvas id="mazeCanvas" width="800" height="600" aria-label="Maze game"></canvas>
    <div class="stats">
      <div>Time: <strong id="time">0s</strong></div>
      <div>Best: <strong id="best">—</strong></div>
    </div>

    <p style="margin-top:12px;color:#445">Use arrow keys or WASD to move. Reach the green cell (goal).</p>
  </main>

  <script>
    (function(){
      const canvas = document.getElementById('mazeCanvas');
      const ctx = canvas.getContext('2d');
      const genBtn = document.getElementById('genBtn');
      const solveBtn = document.getElementById('solveBtn');
      const resetBtn = document.getElementById('resetBtn');
      const sizeRange = document.getElementById('sizeRange');
      const cellRange = document.getElementById('cellRange');
      const movesEl = document.getElementById('moves');
      const timeEl = document.getElementById('time');
      const bestEl = document.getElementById('best');

      let cols = 24, rows = 24, cell = 20;
      let grid = [], stack = [];
      let player = {c:0,r:0}, goal = {c:0,r:0};
      let startTime = null, timerId = null, moves = 0;

      function resizeCanvas(){
        canvas.width = cols * cell;
        canvas.height = rows * cell;
        canvas.style.maxWidth = '100%';
      }

      function idx(c,r){ return r*cols + c; }

      // cell walls: [top,right,bottom,left] true means wall exists
      function makeGrid(){
        grid = new Array(cols*rows).fill(0).map(()=>({walls:[1,1,1,1], visited:false}));
      }

      function neighbors(c,r){
        const list = [];
        if(r>0) list.push({c:c,r:r-1,dir:0,opp:2});
        if(c<cols-1) list.push({c:c+1,r:r,dir:1,opp:3});
        if(r<rows-1) list.push({c:c,r:r+1,dir:2,opp:0});
        if(c>0) list.push({c:c-1,r:r,dir:3,opp:1});
        return list;
      }

      function generateMaze(){
        makeGrid();
        stack = [];
        const startC = 0, startR = 0;
        grid[idx(startC,startR)].visited = true;
        stack.push({c:startC,r:startR});

        while(stack.length){
          const cur = stack[stack.length-1];
          const nbs = neighbors(cur.c,cur.r).filter(n=>!grid[idx(n.c,n.r)].visited);
          if(nbs.length === 0){ stack.pop(); continue; }
          const nxt = nbs[Math.floor(Math.random()*nbs.length)];
          grid[idx(cur.c,cur.r)].walls[nxt.dir] = 0;
          grid[idx(nxt.c,nxt.r)].walls[nxt.opp] = 0;
          grid[idx(nxt.c,nxt.r)].visited = true;
          stack.push({c:nxt.c,r:nxt.r});
        }
        // reset visited flag for pathfinding
        grid.forEach(g=>g.visited=false);
      }

      function drawMaze(){
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.strokeStyle = '#203a66';
        ctx.lineWidth = Math.max(1, cell/12);
        for(let r=0;r<rows;r++){
          for(let c=0;c<cols;c++){
            const x = c*cell, y = r*cell;
            const cellObj = grid[idx(c,r)];
            ctx.beginPath();
            if(cellObj.walls[0]){ ctx.moveTo(x,y); ctx.lineTo(x+cell,y); }
            if(cellObj.walls[1]){ ctx.moveTo(x+cell,y); ctx.lineTo(x+cell,y+cell); }
            if(cellObj.walls[2]){ ctx.moveTo(x+cell,y+cell); ctx.lineTo(x,y+cell); }
            if(cellObj.walls[3]){ ctx.moveTo(x,y+cell); ctx.lineTo(x,y); }
            ctx.stroke();
          }
        }
        // draw player as blue circle
        drawPlayer();
        // draw goal as green square
        ctx.fillStyle = '#2ecc71';
        ctx.fillRect(goal.c*cell + cell*0.2, goal.r*cell + cell*0.2, cell*0.6, cell*0.6);
      }

      function drawPlayer(){
        ctx.fillStyle = '#1565c0';
        const cx = player.c*cell + cell/2; const cy = player.r*cell + cell/2;
        ctx.beginPath(); ctx.arc(cx,cy,Math.max(4,cell*0.28),0,Math.PI*2); ctx.fill();
      }

      function canMove(c,r,dir){
        if(c<0||r<0||c>=cols||r>=rows) return false;
        return grid[idx(c,r)].walls[dir] === 0;
      }

      function move(dir){
        // dir: 0 up,1 right,2 down,3 left
        let nc=player.c, nr=player.r;
        if(dir===0 && canMove(player.c,player.r,0)) nr--;
        else if(dir===1 && canMove(player.c,player.r,1)) nc++;
        else if(dir===2 && canMove(player.c,player.r,2)) nr++;
        else if(dir===3 && canMove(player.c,player.r,3)) nc--;
        if(nc===player.c && nr===player.r) return; // blocked
        player.c = nc; player.r = nr; moves++; movesEl.textContent = moves;
        drawMaze();
        checkGoal();
      }

      function checkGoal(){
        if(player.c === goal.c && player.r === goal.r){
          stopTimer();
          const timeSec = Math.floor((Date.now()-startTime)/1000);
          timeEl.textContent = timeSec + 's';
          const key = `mini-maze-best-${cols}x${rows}-${cell}`;
          const prev = Number(localStorage.getItem(key) || 0);
          if(prev === 0 || timeSec < prev) { localStorage.setItem(key, timeSec); bestEl.textContent = timeSec + 's'; }
          else bestEl.textContent = prev + 's';
          alert('You reached the goal! Time: ' + timeSec + 's, moves: ' + moves);
        }
      }

      function startTimer(){ startTime = Date.now(); if(timerId) clearInterval(timerId); timerId = setInterval(()=>{ const s = Math.floor((Date.now()-startTime)/1000); timeEl.textContent = s + 's'; },1000); }
      function stopTimer(){ if(timerId) clearInterval(timerId); timerId = null; }

      function placePlayerAndGoal(){
        player.c = 0; player.r = 0;
        goal.c = cols-1; goal.r = rows-1;
        moves = 0; movesEl.textContent = moves; timeEl.textContent = '0s';
        const key = `mini-maze-best-${cols}x${rows}-${cell}`;
        const prev = localStorage.getItem(key);
        bestEl.textContent = prev ? prev+'s' : '—';
      }

      function regenerate(){
        cols = Math.max(8, Number(sizeRange.value)); rows = cols; cell = Math.max(8, Number(cellRange.value));
        resizeCanvas();
        generateMaze();
        placePlayerAndGoal();
        drawMaze();
      }

      // simple BFS to show path (not animated)
      function solve(){
        const q = [{c:player.c,r:player.r,from:-1}];
        const visited = new Array(cols*rows).fill(false);
        visited[idx(player.c,player.r)] = true;
        let found = -1;
        for(let i=0;i<q.length;i++){
          const cur = q[i];
          if(cur.c===goal.c && cur.r===goal.r){ found = i; break; }
          const dirs = neighbors(cur.c,cur.r);
          for(const d of dirs){ if(grid[idx(cur.c,cur.r)].walls[d.dir]===0 && !visited[idx(d.c,d.r)]){ visited[idx(d.c,d.r)]=true; q.push({c:d.c,r:d.r,from:i, dir:d.dir}); } }
        }
        if(found === -1) return;
        // reconstruct
        const path = [];
        let curIdx = found;
        while(curIdx !== -1){ path.push({c:q[curIdx].c,r:q[curIdx].r}); curIdx = q[curIdx].from; }
        // draw path
        ctx.fillStyle = 'rgba(255,200,0,0.6)';
        for(const p of path){ ctx.fillRect(p.c*cell + cell*0.28, p.r*cell + cell*0.28, cell*0.44, cell*0.44); }
        drawPlayer();
      }

      // input
      document.addEventListener('keydown', (e)=>{
        if(['ArrowUp','w','W'].includes(e.key)) move(0);
        else if(['ArrowRight','d','D'].includes(e.key)) move(1);
        else if(['ArrowDown','s','S'].includes(e.key)) move(2);
        else if(['ArrowLeft','a','A'].includes(e.key)) move(3);
      });

      genBtn.addEventListener('click', ()=>{ regenerate(); startTimer(); });
      resetBtn.addEventListener('click', ()=>{ regenerate(); });
      solveBtn.addEventListener('click', solve);

      // initialize defaults
      resizeCanvas();
      regenerate();
      // small start timer only after first generate
    })();
  </script>
</body>
</html>
